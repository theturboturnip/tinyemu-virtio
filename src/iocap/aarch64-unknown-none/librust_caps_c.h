/**
* A library for using I/O capabilities with cryptographic protection, a.k.a. crypto-caps, a.k.a. ccaps.
* Generated by cbindgen from the rust_caps_c Rust crate version 0.4.6.
*/

#ifndef LIBRUST_CAPS_C_H
#define LIBRUST_CAPS_C_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

enum CCapPerms
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  CCapPerms_Read = 1,
  CCapPerms_Write = 2,
  CCapPerms_ReadWrite = 3,
};
#ifndef __cplusplus
typedef uint8_t CCapPerms;
#endif // __cplusplus

enum CCapResult
#ifdef __cplusplus
  : int32_t
#endif // __cplusplus
 {
  CCapResult_Success = 0,
  CCapResult_Encode_UnrepresentableBaseRange = 1,
  CCapResult_Encode_UnrepresentableCaveat = 2,
  CCapResult_Encode_InvalidCaveat = 3,
  CCapResult_Encode_NoCaveatsLeft = 4,
  CCapResult_Encode_CantShrinkPerms = 5,
  CCapResult_Decode_InvalidCaveat = 6,
  CCapResult_Decode_InvalidSignature = 7,
  CCapResult_Decode_InvalidCapPermsChain = 8,
  CCapResult_Decode_UnexpectedCaveat = 9,
  CCapResult_NullRequiredArgs = 100,
};
#ifndef __cplusplus
typedef int32_t CCapResult;
#endif // __cplusplus

/**
 * Little-endian representation of a 128-bit number
 */
typedef uint8_t CCapU128[16];

typedef struct CCap2024_02 {
  CCapU128 signature;
  CCapU128 data;
} CCap2024_02;

typedef struct CCap2024_11 {
  CCapU128 signature;
  CCapU128 data;
} CCap2024_11;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Convert a CCapPerms enum to a null-terminated static immutable C string.
 * Invokes undefined behaviour if passed an value not in the enumeration.
 */
const char *ccap_perms_str(CCapPerms perms);

/**
 * Convert a CCapResult enum to a null-terminated static immutable C string.
 * Invokes undefined behaviour if passed an value not in the enumeration.
 */
const char *ccap_result_str(CCapResult res);

/**
 * Initialize a capability from scratch allowing access to the full 64-bit address range (base = 0, len = 1<<64), given the permissions (Read|Write|Both), and the secret id.
 * Calculates the capability signature given the packed data and the secret.
 *
 * cap and secret are non-optional, and the function returns `NullRequiredArgs` if either are null.
 *
 * Does not use caveats.
 */
CCapResult ccap2024_02_init_almighty(struct CCap2024_02 *cap,
                                     const CCapU128 *secret,
                                     uint32_t secret_id,
                                     CCapPerms perms);

/**
 * Initialize a capability from scratch, given the contiguous memory range it grants access to, the permissions (Read|Write|Both), and the secret_id.
 * Only uses the initial resource.
 * Calculates the capability signature given the packed data and the secret.
 *
 * cap and secret are non-optional, and the function returns `NullRequiredArgs` if either are null.
 *
 * Returns an Encode error if the base/length is not exactly representable.
 * Use [ccap$version_init_inexact] to allow rounding the bounds up in this case instead of returning an error.
 *
 * Does not use caveats.
 */
CCapResult ccap2024_02_init_exact(struct CCap2024_02 *cap,
                                  const CCapU128 *secret,
                                  uint64_t base,
                                  uint64_t len,
                                  uint32_t secret_id,
                                  CCapPerms perms);

/**
 * Initialize a capability from scratch, given the contiguous memory range it grants access to, the permissions (Read|Write|Both), and the secret_id.
 * Uses the initial resource and both caveats if necessary.
 * Calculates the capability signature given the packed data and the secret.
 */
CCapResult ccap2024_02_init_cavs_exact(struct CCap2024_02 *cap,
                                       const CCapU128 *secret,
                                       uint64_t base,
                                       uint64_t len,
                                       uint32_t secret_id,
                                       CCapPerms perms);

/**
 * Initialize a capability from scratch, given the contiguous memory range it grants access to, the permissions (Read|Write|Both), and the secret_id.
 * Calculates the capability signature given the packed data and the secret.
 *
 * cap and secret are non-optional, and the function returns `NullRequiredArgs` if either are null.
 *
 * Will round the bounds up to the smallest possible value that encloses [base, base+len].
 * If exact bounds are required use [ccap$version_init_exact].
 *
 * Does not use caveats.
 */
CCapResult ccap2024_02_init_inexact(struct CCap2024_02 *cap,
                                    const CCapU128 *secret,
                                    uint64_t base,
                                    uint64_t len,
                                    uint32_t secret_id,
                                    CCapPerms perms);

/**
 * Check if a capability has a valid signature, assuming it was encrypted with the given secret.
 *
 * cap and secret are non-optional, and the function returns `CCapResult_NullRequiredArgs` if either are null.
 *
 * Returns `CCapResult_Success` if the signature is valid.
 * Returns `CCapResult_DecodeInvalidSignature` if the signature is invalid.
 * Returns other errors if the capability is otherwise malformed.
 */
CCapResult ccap2024_02_check_signature(const struct CCap2024_02 *cap,
                                       const CCapU128 *secret);

/**
 * Given a pointer to a capability, read off its base and length.
 * len_64 will be set if the range.len() has the 64th bit set.
 * base, len, and len_64 are optional arguments, and are ignored if null.
 * cap is non-optional, and the function returns `NullRequiredArgs` if null.
 * Returns a Decode error if the capability data is invalid.
 * Doesn't check the capability signature.
 */
CCapResult ccap2024_02_read_range(const struct CCap2024_02 *cap,
                                  uint64_t *base,
                                  uint64_t *len,
                                  bool *len_64);

/**
 * Given a pointer to a capability, read off it's permissions (Read, Write, or both).
 * cap and perms are non-optional, and the function returns `NullRequiredArgs` if they're null.
 * Returns a Decode error if the capability permissions field is invalid, but does not check any other part of the capability.
 * Doesn't check the capability signature.
 */
CCapResult ccap2024_02_read_perms(const struct CCap2024_02 *cap,
                                  CCapPerms *perms);

/**
 * Given a pointer to a capability, read off the secret-key id it claims to use.
 * cap and secret_id are non-optional, and the function returns `NullRequiredArgs` if they're null.
 * Returns a Decode error if the capability data is invalid.
 * Doesn't check the capability signature.
 */
CCapResult ccap2024_02_read_secret_id(const struct CCap2024_02 *cap, uint32_t *secret_id);

/**
 * Randomly generates a valid capability (i.e. one with a valid signature, which decodes with no errors, encoding a nonzero address range) with 0, 1, or 2 caveats based on the seed.
 *
 * cap and seed are non-optional, and the function returns `NullRequiredArgs` if they're null.
 *
 * secret_key and secret_key_id may be null, in which case they will be randomly generated based on the seed.
 */
CCapResult ccap2024_02_rand_valid_cap(struct CCap2024_02 *cap,
                                      const CCapU128 *seed,
                                      const CCapU128 *secret_key,
                                      const uint32_t *secret_key_id);

/**
 * Randomly generates a valid capability (i.e. one with a valid signature, which decodes with no errors, encoding a nonzero address range) with 0 caveats based on the seed.
 *
 * cap and seed are non-optional, and the function returns `NullRequiredArgs` if they're null.
 *
 * secret_key and secret_key_id may be null, in which case they will be randomly generated based on the seed.
 */
CCapResult ccap2024_02_rand_valid_cap_0cav(struct CCap2024_02 *cap,
                                           const CCapU128 *seed,
                                           const CCapU128 *secret_key,
                                           const uint32_t *secret_key_id);

/**
 * Randomly generates a valid capability (i.e. one with a valid signature, which decodes with no errors, encoding a nonzero address range) with 1 caveat based on the seed.
 *
 * cap and seed are non-optional, and the function returns `NullRequiredArgs` if they're null.
 *
 * secret_key and secret_key_id may be null, in which case they will be randomly generated based on the seed.
 */
CCapResult ccap2024_02_rand_valid_cap_1cav(struct CCap2024_02 *cap,
                                           const CCapU128 *seed,
                                           const CCapU128 *secret_key,
                                           const uint32_t *secret_key_id);

/**
 * Randomly generates a valid capability (i.e. one with a valid signature, which decodes with no errors, encoding a nonzero address range) with 2 caveats based on the seed.
 *
 * cap and seed are non-optional, and the function returns `NullRequiredArgs` if they're null.
 *
 * secret_key and secret_key_id may be null, in which case they will be randomly generated based on the seed.
 */
CCapResult ccap2024_02_rand_valid_cap_2cav(struct CCap2024_02 *cap,
                                           const CCapU128 *seed,
                                           const CCapU128 *secret_key,
                                           const uint32_t *secret_key_id);

/**
 * Randomly generates a capability using one of the "edge case" generators.
 * The number of edge cases for ccap$version is returned by [ccap$version_rand_edge_case_num].
 * Panics if the supplied edge case number >= [ccap$version_rand_edge_case_num].
 *
 * cap and seed are non-optional, and the function returns `NullRequiredArgs` if they're null.
 *
 * secret_key and secret_key_id may be null, in which case they will be randomly generated based on the seed.
 */
CCapResult ccap2024_02_rand_edge_case_cap(struct CCap2024_02 *cap,
                                          const CCapU128 *seed,
                                          const CCapU128 *secret_key,
                                          const uint32_t *secret_key_id,
                                          uintptr_t edge_case);

/**
 * Returns the number of "edge case" random generators created for ccap$version
 */
uintptr_t ccap2024_02_rand_edge_case_num(void);

/**
 * Converts an edge case number smaller than [ccap$version_rand_edge_case_num] to a string describing the specific edge case.
 *
 * Panics if the number is greater than or equal to the [ccap$version_rand_edge_case_num]
 */
const char *ccap2024_02_rand_edge_case_str(uintptr_t edge_case);

/**
 * Initialize a capability from scratch allowing access to the full 64-bit address range (base = 0, len = 1<<64), given the permissions (Read|Write|Both), and the secret id.
 * Calculates the capability signature given the packed data and the secret.
 *
 * cap and secret are non-optional, and the function returns `NullRequiredArgs` if either are null.
 *
 * Does not use caveats.
 */
CCapResult ccap2024_11_init_almighty(struct CCap2024_11 *cap,
                                     const CCapU128 *secret,
                                     uint32_t secret_id,
                                     CCapPerms perms);

/**
 * Initialize a capability from scratch, given the contiguous memory range it grants access to, the permissions (Read|Write|Both), and the secret_id.
 * Only uses the initial resource.
 * Calculates the capability signature given the packed data and the secret.
 *
 * cap and secret are non-optional, and the function returns `NullRequiredArgs` if either are null.
 *
 * Returns an Encode error if the base/length is not exactly representable.
 * Use [ccap$version_init_inexact] to allow rounding the bounds up in this case instead of returning an error.
 *
 * Does not use caveats.
 */
CCapResult ccap2024_11_init_exact(struct CCap2024_11 *cap,
                                  const CCapU128 *secret,
                                  uint64_t base,
                                  uint64_t len,
                                  uint32_t secret_id,
                                  CCapPerms perms);

/**
 * Initialize a capability from scratch, given the contiguous memory range it grants access to, the permissions (Read|Write|Both), and the secret_id.
 * Uses the initial resource and both caveats if necessary.
 * Calculates the capability signature given the packed data and the secret.
 */
CCapResult ccap2024_11_init_cavs_exact(struct CCap2024_11 *cap,
                                       const CCapU128 *secret,
                                       uint64_t base,
                                       uint64_t len,
                                       uint32_t secret_id,
                                       CCapPerms perms);

/**
 * Initialize a capability from scratch, given the contiguous memory range it grants access to, the permissions (Read|Write|Both), and the secret_id.
 * Calculates the capability signature given the packed data and the secret.
 *
 * cap and secret are non-optional, and the function returns `NullRequiredArgs` if either are null.
 *
 * Will round the bounds up to the smallest possible value that encloses [base, base+len].
 * If exact bounds are required use [ccap$version_init_exact].
 *
 * Does not use caveats.
 */
CCapResult ccap2024_11_init_inexact(struct CCap2024_11 *cap,
                                    const CCapU128 *secret,
                                    uint64_t base,
                                    uint64_t len,
                                    uint32_t secret_id,
                                    CCapPerms perms);

/**
 * Check if a capability has a valid signature, assuming it was encrypted with the given secret.
 *
 * cap and secret are non-optional, and the function returns `CCapResult_NullRequiredArgs` if either are null.
 *
 * Returns `CCapResult_Success` if the signature is valid.
 * Returns `CCapResult_DecodeInvalidSignature` if the signature is invalid.
 * Returns other errors if the capability is otherwise malformed.
 */
CCapResult ccap2024_11_check_signature(const struct CCap2024_11 *cap,
                                       const CCapU128 *secret);

/**
 * Given a pointer to a capability, read off its base and length.
 * len_64 will be set if the range.len() has the 64th bit set.
 * base, len, and len_64 are optional arguments, and are ignored if null.
 * cap is non-optional, and the function returns `NullRequiredArgs` if null.
 * Returns a Decode error if the capability data is invalid.
 * Doesn't check the capability signature.
 */
CCapResult ccap2024_11_read_range(const struct CCap2024_11 *cap,
                                  uint64_t *base,
                                  uint64_t *len,
                                  bool *len_64);

/**
 * Given a pointer to a capability, read off it's permissions (Read, Write, or both).
 * cap and perms are non-optional, and the function returns `NullRequiredArgs` if they're null.
 * Returns a Decode error if the capability permissions field is invalid, but does not check any other part of the capability.
 * Doesn't check the capability signature.
 */
CCapResult ccap2024_11_read_perms(const struct CCap2024_11 *cap,
                                  CCapPerms *perms);

/**
 * Given a pointer to a capability, read off the secret-key id it claims to use.
 * cap and secret_id are non-optional, and the function returns `NullRequiredArgs` if they're null.
 * Returns a Decode error if the capability data is invalid.
 * Doesn't check the capability signature.
 */
CCapResult ccap2024_11_read_secret_id(const struct CCap2024_11 *cap, uint32_t *secret_id);

/**
 * Randomly generates a valid capability (i.e. one with a valid signature, which decodes with no errors, encoding a nonzero address range) with 0, 1, or 2 caveats based on the seed.
 *
 * cap and seed are non-optional, and the function returns `NullRequiredArgs` if they're null.
 *
 * secret_key and secret_key_id may be null, in which case they will be randomly generated based on the seed.
 */
CCapResult ccap2024_11_rand_valid_cap(struct CCap2024_11 *cap,
                                      const CCapU128 *seed,
                                      const CCapU128 *secret_key,
                                      const uint32_t *secret_key_id);

/**
 * Randomly generates a valid capability (i.e. one with a valid signature, which decodes with no errors, encoding a nonzero address range) with 0 caveats based on the seed.
 *
 * cap and seed are non-optional, and the function returns `NullRequiredArgs` if they're null.
 *
 * secret_key and secret_key_id may be null, in which case they will be randomly generated based on the seed.
 */
CCapResult ccap2024_11_rand_valid_cap_0cav(struct CCap2024_11 *cap,
                                           const CCapU128 *seed,
                                           const CCapU128 *secret_key,
                                           const uint32_t *secret_key_id);

/**
 * Randomly generates a valid capability (i.e. one with a valid signature, which decodes with no errors, encoding a nonzero address range) with 1 caveat based on the seed.
 *
 * cap and seed are non-optional, and the function returns `NullRequiredArgs` if they're null.
 *
 * secret_key and secret_key_id may be null, in which case they will be randomly generated based on the seed.
 */
CCapResult ccap2024_11_rand_valid_cap_1cav(struct CCap2024_11 *cap,
                                           const CCapU128 *seed,
                                           const CCapU128 *secret_key,
                                           const uint32_t *secret_key_id);

/**
 * Randomly generates a valid capability (i.e. one with a valid signature, which decodes with no errors, encoding a nonzero address range) with 2 caveats based on the seed.
 *
 * cap and seed are non-optional, and the function returns `NullRequiredArgs` if they're null.
 *
 * secret_key and secret_key_id may be null, in which case they will be randomly generated based on the seed.
 */
CCapResult ccap2024_11_rand_valid_cap_2cav(struct CCap2024_11 *cap,
                                           const CCapU128 *seed,
                                           const CCapU128 *secret_key,
                                           const uint32_t *secret_key_id);

/**
 * Randomly generates a capability using one of the "edge case" generators.
 * The number of edge cases for ccap$version is returned by [ccap$version_rand_edge_case_num].
 * Panics if the supplied edge case number >= [ccap$version_rand_edge_case_num].
 *
 * cap and seed are non-optional, and the function returns `NullRequiredArgs` if they're null.
 *
 * secret_key and secret_key_id may be null, in which case they will be randomly generated based on the seed.
 */
CCapResult ccap2024_11_rand_edge_case_cap(struct CCap2024_11 *cap,
                                          const CCapU128 *seed,
                                          const CCapU128 *secret_key,
                                          const uint32_t *secret_key_id,
                                          uintptr_t edge_case);

/**
 * Returns the number of "edge case" random generators created for ccap$version
 */
uintptr_t ccap2024_11_rand_edge_case_num(void);

/**
 * Converts an edge case number smaller than [ccap$version_rand_edge_case_num] to a string describing the specific edge case.
 *
 * Panics if the number is greater than or equal to the [ccap$version_rand_edge_case_num]
 */
const char *ccap2024_11_rand_edge_case_str(uintptr_t edge_case);

#if !defined(LIBRUST_CAPS_C_HOSTED)
/**
 * A function called when librust_caps_c panics to print debug information.
 *
 * This function is *not* defined by librust_caps_c, and must be defined by the target linking the library in.
 */
extern uint64_t ccap_panic_write_utf8(const uint8_t *utf8,
                                      uint64_t utf_len);
#endif

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* LIBRUST_CAPS_C_H */
